#!/usr/bin/env python3

"""Listen to kernel input events and translate to Mopidy commands.

"""

import argparse
import asyncio
from enum import Enum
import logging
import random
from typing import (Any, Awaitable, Callable, List, Dict, NamedTuple,
                    Optional, Tuple)

import aiohttp
from evdev import InputDevice, categorize, ecodes

MOPIDY_URL = "http://localhost:6680/mopidy/rpc"

LOGGER = logging.getLogger("argosir")

DEFAULT_DEVICE = "/dev/input/event0"

VOLUME_STEP = 10


class KeyDirection(Enum):
    UP = 0
    DOWN = 1
    HOLD = 2


Callback = Callable[[], Awaitable[None]]


class KeyConf(NamedTuple):
    direction: KeyDirection
    key: str
    callback: Callback


Callbacks = Dict[Tuple[KeyDirection, str], Callback]

_COMMAND_ID = 0

_SESSION: Optional[aiohttp.ClientSession] = None


def get_parser() -> argparse.ArgumentParser:
    global DEFAULT_DEVICE
    global MOPIDY_URL
    parser = argparse.ArgumentParser(description=__doc__, prog="argosir")

    parser.add_argument("--debug", action="store_true",
                        help="enable debug logs")

    d_help = "path of device to listen events for "
    d_help += f"(default: {DEFAULT_DEVICE!r})"
    parser.add_argument("-d", "--device", type=str, default=DEFAULT_DEVICE,
                        help=d_help)

    u_help = "URL of the Mopidy RPC-JSON API to act on "
    u_help += "(default: {MOPIDY_URL!r})"
    parser.add_argument("-u", "--url", type=str, default=MOPIDY_URL,
                        help=u_help)

    return parser


def configure_logger(args: argparse.Namespace):
    ch = logging.StreamHandler()
    formatter = logging.Formatter("%(levelname)s: %(message)s")
    ch.setFormatter(formatter)
    level = logging.DEBUG if args.debug is True else logging.INFO
    ch.setLevel(level)
    logger = logging.getLogger("argosir")
    logger.setLevel(level)
    logger.addHandler(ch)


async def send_command(method: str, *, params: dict = None) -> Any:
    """Send a command to Mopidy RPC-JSON HTTP interface."""
    global _COMMAND_ID
    global _SESSION
    if not _SESSION:
        raise RuntimeError("HTTP client session not found")

    data = {"jsonrpc": "2.0",
            "id": _COMMAND_ID,
            "method": method}
    if params is not None:
        data["params"] = params

    try:
        LOGGER.debug(f"Sending POST {MOPIDY_URL} {data}")
        async with _SESSION.post(MOPIDY_URL, json=data) as resp:
            content = await resp.json()
            LOGGER.debug(f"Received {content}")
            if "result" in content:
                return content["result"]
    except aiohttp.ClientResponseError as err:
        LOGGER.error(f"Failed to request mopidy server, {err}")


async def next_track():
    await send_command("core.playback.next")


async def previous_track():
    await send_command("core.playback.previous")


async def pause_or_resume():
    state = await send_command("core.playback.get_state")
    if state == "playing":
        await send_command("core.playback.pause")
    elif state == "paused":
        await send_command("core.playback.resume")
    elif state == "stopped":
        await send_command("core.playback.play")
    else:
        LOGGER.error(f"Unexpected state, {state}")


async def play_random_album():
    albums = await send_command("core.library.browse",
                                params={"uri": "local:directory?type=album"})
    LOGGER.info(f"Found {len(albums)} albums")
    album = random.choice(albums)
    LOGGER.info(f"Will play {album['name']}")
    await send_command("core.tracklist.clear")
    await send_command("core.tracklist.add", params={"uris": [album["uri"]]})
    await send_command("core.playback.play")


async def mute_unmute():
    mute = await send_command("core.mixer.get_mute")
    await send_command("core.mixer.set_mute", params={"mute": not mute})


async def volume_up():
    volume = await send_command("core.mixer.get_volume")
    new_volume = min(volume + VOLUME_STEP, 100)
    if new_volume != volume:
        await send_command("core.mixer.set_volume",
                           params={"volume": new_volume})


async def volume_down():
    volume = await send_command("core.mixer.get_volume")
    new_volume = max(volume - VOLUME_STEP, 0)
    if new_volume != volume:
        await send_command("core.mixer.set_volume",
                           params={"volume": new_volume})


async def play_france_culture():
    tltrack = await send_command("core.playback.get_current_tl_track")
    if tltrack:
        track = tltrack["track"]
        if track["name"] == "franceculture-midfi.mp3":
            await send_command("core.playback.next")
            tlid = tltrack["tlid"]
            await send_command("core.tracklist.remove",
                               params={"criteria": ("tlid", [tlid])})
            return

    lists = await send_command("core.playlists.as_list")
    try:
        rf_list = next(filter(
            lambda l: l["name"] == "Radio France", lists))
    except StopIteration:
        LOGGER.warning(f"Radio France playlist not found")
        return
    refs = await send_command("core.playlists.get_items",
                              params={"uri": rf_list["uri"]})
    try:
        fc_ref = next(filter(
            lambda ref: ref["name"] == "France Culture", refs))
    except StopIteration:
        LOGGER.warning(f"France Culture ref not found")
        return
    current_index = await send_command("core.tracklist.index")
    target_index = current_index if current_index is not None else 0
    tltracks = await send_command("core.tracklist.add",
                                  params={"uris": [fc_ref["uri"]],
                                          "at_position": target_index})
    tltrack = tltracks[0]
    await send_command("core.playback.play",
                       params={"tlid": tltrack["tlid"]})


# See rc_keymaps/smsl_a8 for mapped keys


KEY_CONF: List[KeyConf] \
    = [KeyConf(KeyDirection.UP, "KEY_RIGHT", next_track),
       KeyConf(KeyDirection.UP, "KEY_LEFT", previous_track),
       KeyConf(KeyDirection.UP, "KEY_ENTER", pause_or_resume),
       KeyConf(KeyDirection.DOWN, "KEY_MIN_INTERESTING", mute_unmute),
       KeyConf(KeyDirection.UP, "KEY_UP", volume_up),
       KeyConf(KeyDirection.UP, "KEY_DOWN", volume_down),
       KeyConf(KeyDirection.UP, "KEY_SELECT", play_random_album),
       KeyConf(KeyDirection.UP, "KEY_FN", play_france_culture)]


def parse_key_conf() -> Callbacks:
    """Parse and index the key configurations.

    Key configurations are read from the global ``KEY_CONF``.

    """
    global KEY_CONF
    callbacks: Callbacks = dict()
    for keyconf in KEY_CONF:
        callback_key = (keyconf.direction.value, keyconf.key)
        callbacks[callback_key] = keyconf.callback
        msg = f"{keyconf.key!r} {keyconf.direction} " \
            f"mapped to {keyconf.callback.__name__!r}"
        LOGGER.info(msg)
    return callbacks


async def consumer(dev: InputDevice, callbacks: Callbacks):
    """Read kernel input events and try to translate to function calls.

    Args:
        dev: The device to pay attention to

        callbacks: Mapping from key events to callback functions

    """
    global _SESSION
    async with aiohttp.ClientSession(raise_for_status=True) as session:
        _SESSION = session
        async for ev in dev.async_read_loop():
            if ev.type == ecodes.EV_KEY:
                ev = categorize(ev)
                keys = [(ev.keystate, kc) for kc in ev.keycode] \
                    if isinstance(ev.keycode, list) \
                    else [(ev.keystate, ev.keycode)]
                callback = None
                for key in keys:
                    try:
                        callback = callbacks[key]
                    except KeyError:
                        continue

                if not callback:
                    LOGGER.debug(f"Nothing to do for {ev}")
                    continue

                LOGGER.info(f"Calling {callback.__name__}")
                await callback()


if __name__ == "__main__":
    parser = get_parser()
    args = parser.parse_args()

    configure_logger(args)

    dev = InputDevice(args.device)
    LOGGER.info(f"Listening to {dev}...")
    LOGGER.debug(f"Device capabilities: {dev.capabilities(verbose=True)}...")

    callbacks = parse_key_conf()

    loop = asyncio.get_event_loop()
    loop.run_until_complete(consumer(dev, callbacks))
